Env	phrase.c	/^} Env;$/
Expr	phrase.c	/^} Expr;$/
List	phrase.c	/^} List;$/
List_v	phrase.c	/^} List_v;$/
Mphrase	phrase.c	/^main(int argc, char **argv) {$/
Phrase	phrase.c	/^} Phrase;$/
Rstatus	phrase.c	/^typedef enum {LINE, EMPTY, END, ERR} Rstatus;$/
Sem	phrase.c	/^typedef union Sem_ Sem;$/
State	phrase.c	/^} State;		\/* return type for evaluation *\/$/
Symop	phrase.c	/^} Symop;$/
Symval	phrase.c	/^} Symval;$/
Val	phrase.c	/^typedef union Val_ Val;$/
Word	phrase.c	/^} Word;$/
added_sym	phrase.c	/^added_sym(Env *a, Symval *b, bool err) {$/
copy_v	phrase.c	/^copy_v(Val *a) {$/
exp_of_words	phrase.c	/^exp_of_words(char *a) {$/
expr	phrase.c	/^expr() {$/
free_env	phrase.c	/^free_env(Env *a) {$/
free_ph	phrase.c	/^free_ph(Phrase *a) {$/
free_s	phrase.c	/^free_s(Sem *a) {$/
free_symval	phrase.c	/^free_symval(Symval *a) {$/
free_v	phrase.c	/^free_v(Val *a) {$/
free_x	phrase.c	/^free_x(Expr *a) {$/
infer	phrase.c	/^infer(Env *e, Val *a, bool look) {$/
infer_and	phrase.c	/^infer_and(Env *e, Val *s, size_t p) {$/
infer_call	phrase.c	/^infer_call(Env *e, Val *s, size_t p) {$/
infer_div	phrase.c	/^infer_div(Env *e, Val *s, size_t p) {$/
infer_do	phrase.c	/^infer_do(Env *e, Val *s, size_t p) {$/
infer_eq	phrase.c	/^infer_eq(Env *e, Val *s, size_t p) {$/
infer_eqv	phrase.c	/^infer_eqv(Env *e, Val *s, size_t p) {$/
infer_false	phrase.c	/^infer_false(Env *e, Val *s, size_t p) {$/
infer_fun	phrase.c	/^infer_fun(Env *e, Val *s, size_t p) {$/
infer_funend	phrase.c	/^infer_funend(Env *e, Val *s, size_t p) {$/
infer_geq	phrase.c	/^infer_geq(Env *e, Val *s, size_t p) {$/
infer_gre	phrase.c	/^infer_gre(Env *e, Val *s, size_t p) {$/
infer_if	phrase.c	/^infer_if(Env *e, Val *s, size_t p) {$/
infer_infix_arg	phrase.c	/^infer_infix_arg(Env *e, Val *s, size_t p, Val **pa/
infer_items	phrase.c	/^infer_items(Env *e, Val *a, bool look) {$/
infer_leq	phrase.c	/^infer_leq(Env *e, Val *s, size_t p) {$/
infer_les	phrase.c	/^infer_les(Env *e, Val *s, size_t p) {$/
infer_list	phrase.c	/^infer_list(Env *e, Val *s, size_t p) {$/
infer_look	phrase.c	/^infer_look(Env *e, Val *s, size_t p) {$/
infer_min	phrase.c	/^infer_min(Env *e, Val *s, size_t p) {$/
infer_mul	phrase.c	/^infer_mul(Env *e, Val *s, size_t p) {$/
infer_neq	phrase.c	/^infer_neq(Env *e, Val *s, size_t p) {$/
infer_not	phrase.c	/^infer_not(Env *e, Val *s, size_t p) {$/
infer_or	phrase.c	/^infer_or(Env *e, Val *s, size_t p) {$/
infer_ph	phrase.c	/^infer_ph(Env *e_o, Phrase *a) {$/
infer_plu	phrase.c	/^infer_plu(Env *e, Val *s, size_t p) {$/
infer_prefix1_arg	phrase.c	/^infer_prefix1_arg(Env *e, Val *s, size_t p, Val **/
infer_prefix2_arg	phrase.c	/^infer_prefix2_arg(Env *e, Val *s, size_t p, Val **/
infer_prefixn_arg	phrase.c	/^infer_prefixn_arg(Env *e, Val *s, size_t p, Val **/
infer_print	phrase.c	/^infer_print(Env *e, Val *s, size_t p) {$/
infer_rem	phrase.c	/^infer_rem(Env *e, Val *s, size_t p) {$/
infer_seq	phrase.c	/^infer_seq(Env *e, Val *b, bool look) {$/
infer_true	phrase.c	/^infer_true(Env *e, Val *s, size_t p) {$/
infixed	phrase.c	/^infixed(size_t p, size_t n) {$/
isatom_v	phrase.c	/^isatom_v(Val *a) {$/
isequal_v	phrase.c	/^isequal_v(Val *a, Val *b) {$/
isequiv_v	phrase.c	/^isequiv_v(Val *a, Val *b) {$/
isnat	phrase.c	/^isnat(Word *a) {$/
isrea	phrase.c	/^isrea(Word *a) {$/
issym	phrase.c	/^issym(Word *a) {$/
istrue_v	phrase.c	/^istrue_v(Val *a) {$/
lookup	phrase.c	/^lookup(Env *a, char *b) {$/
lookup_id	phrase.c	/^lookup_id(Env *a, char *b, size_t *id) {$/
lookup_op	phrase.c	/^lookup_op(char *a) {$/
lst_of	phrase.c	/^lst_of(Sem *a) {$/
minprio	phrase.c	/^minprio() {$/
phrase	phrase.c	/^phrase() {$/
phrase_of_str	phrase.c	/^phrase_of_str(char *a) {$/
prefixed1	phrase.c	/^prefixed1(size_t p, size_t n) {$/
prefixed2	phrase.c	/^prefixed2(size_t p, size_t n) {$/
print_env	phrase.c	/^print_env(Env *a) {$/
print_ph	phrase.c	/^print_ph(Phrase *a) {$/
print_rc	phrase.c	/^print_rc(State a) {$/
print_s	phrase.c	/^print_s(Sem *a) {$/
print_symval	phrase.c	/^print_symval(Symval *a) {$/
print_v	phrase.c	/^print_v(Val *a) {$/
push_l	phrase.c	/^push_l(List_v a, Val *b) {$/
push_ph	phrase.c	/^push_ph(Phrase *a, char *b) {$/
push_s	phrase.c	/^push_s(Sem *a, Sem *b) {$/
push_v	phrase.c	/^push_v(vtype t, Val *a, Val *b) {$/
push_xz	phrase.c	/^push_xz(Expr *a, Word *b) {$/
readline	phrase.c	/^readline(char **s_o) {$/
sem_nat	phrase.c	/^sem_nat(long long a) {$/
sem_nil	phrase.c	/^sem_nil() {$/
sem_rea	phrase.c	/^sem_rea(double a) {$/
sem_seq	phrase.c	/^sem_seq() {$/
sem_sym	phrase.c	/^sem_sym(char *a) {$/
seme_of_exp	phrase.c	/^seme_of_exp(Expr *a) {$/
seme_of_exp_part	phrase.c	/^seme_of_exp_part(Expr *a, size_t from, size_t tox)/
stored_sym	phrase.c	/^stored_sym(Env *a, Symval *b) {$/
stype	phrase.c	/^typedef enum {SNIL, SNAT, SREA, SSYM, SLST, SSEQ} /
symval	phrase.c	/^symval(char *a, Val *b) {$/
upd_infix	phrase.c	/^upd_infix(Val *s, size_t p, Val *a) {$/
upd_prefix0	phrase.c	/^upd_prefix0(Val *s, size_t p, Val *a) {$/
upd_prefix1	phrase.c	/^upd_prefix1(Val *s, size_t p, Val *a) {$/
upd_prefix2	phrase.c	/^upd_prefix2(Val *s, size_t p, Val *a) {$/
upd_prefixall	phrase.c	/^upd_prefixall(Val *s, size_t p, Val *a) {$/
upd_prefixk	phrase.c	/^upd_prefixk(Val *s, size_t p, Val *a, size_t k) {$/
upded_sym	phrase.c	/^upded_sym(Env *a, Symval *b, bool err) {$/
usage	phrase.c	/^usage(const char *exe) {$/
val_of_seme	phrase.c	/^val_of_seme(Env *e, Sem *s) {$/
voob	phrase.c	/^} voob;  	\/* OOB for out of band *\/$/
vtype	phrase.c	/^typedef enum {VNIL, VNAT, VREA, VSYMOP, VSYMF, VSY/
word	phrase.c	/^word(wtype a) {$/
word_str	phrase.c	/^word_str(char *a, size_t n) {$/
wtype	phrase.c	/^typedef enum { SEP, LEFT, RIGHT, STR } wtype;  $/
